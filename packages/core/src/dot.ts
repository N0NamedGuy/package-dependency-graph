/**
 * @public
 */
export function toDotFile(dependencies: { [name: string]: string[] }) {
  const nodes = new Map<string, string>()
  const maps: string[] = []

  const colors = new Colors(2)

  for (const dependency in dependencies) {
    if (!nodes.has(dependency)) {
      nodes.set(dependency, colors.getNext())
    }
    const name = toName(dependency)
    for (const dependent of dependencies[dependency]) {
      let color = nodes.get(dependent)
      if (!color) {
        color = colors.getNext()
        nodes.set(dependent, color)
      }
      maps.push(`  ${name} -> ${toName(dependent)}[color = "${color}"]`)
    }
  }
  const nodeExpression = Array.from(nodes).map(([n, color]) => `  ${toName(n)}[label = "${n}", color = "${color}"]`)

  return `// generated by package-dependency-graph
digraph {
${maps.join('\n')}

${nodeExpression.join('\n')}
}`
}

function toName(dependency: string) {
  return dependency.replace(/-/g, '_').replace(/\//g, '_').replace(/@/g, '_')
}

class Colors {
  private colors: string[] = []
  private index = 0
  constructor(n: number) {
    for (let i = 0; i <= n; i++) {
      const r = Math.floor(i * 255.0 / n)
      for (let j = 0; j <= n; j++) {
        const g = Math.floor(j * 255.0 / n)
        for (let k = 0; k <= n; k++) {
          const b = Math.floor(k * 255.0 / n)
          if ((255 - r) ** 2 + (255 - g) ** 2 + (255 - b) ** 2 > 20000) {
            this.colors.push(`#${formatColor(r)}${formatColor(g)}${formatColor(b)}`)
          }
        }
      }
    }
  }
  getNext() {
    const color = this.colors[this.index]
    this.index++
    if (this.index >= this.colors.length) {
      this.index = 0
    }
    return color
  }
}

function formatColor(c: number) {
  const result = c.toString(16)
  return result.length === 1 ? '0' + result : result
}
