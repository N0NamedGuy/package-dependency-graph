import { Colors, getCommonParentGroup, NestedGroup, NestedGroupInput, standardizeInput } from '.'

/**
 * @public
 */
export function toDotFile(
  rawDependencies: { [name: string]: (string[]) | { dependencies: string[], group: string } },
  rawNestedGroups: NestedGroupInput[] = [],
) {
  const nodes = new Map<string, string>()
  const subgraphs: string[] = []
  const maps: string[] = []

  const colors = new Colors(2)

  const { dependencies, nestedGroups, flattenedGroups, packageGroups } = standardizeInput(colors, rawDependencies, rawNestedGroups)
  if (nestedGroups.length > 0) {
    subgraphs.push('  graph [compound=true];')
  }

  const mapData: { from: string, to: string }[] = []
  for (const dependency in dependencies) {
    if (!nodes.has(dependency)) {
      nodes.set(dependency, colors.getNext())
    }
    const name = toName(dependency)
    const dependents = dependencies[dependency]
    for (const dependent of dependents) {
      let color = nodes.get(dependent)
      if (!color) {
        color = colors.getNext()
        nodes.set(dependent, color)
      }
      const { fromGroup, toGroup } = getCommonParentGroup(
        packageGroups.find((p) => p.name === dependency),
        packageGroups.find((p) => p.name === dependent),
      )
      const clusters: string[] = []
      if (fromGroup !== toGroup) {
        if (fromGroup) {
          clusters.push(`ltail=cluster_${toName(fromGroup)}`)
        }
        if (toGroup) {
          clusters.push(`lhead=cluster_${toName(toGroup)}`)
          color = flattenedGroups[toGroup].color
        }
        const newMapData = {
          from: fromGroup || dependency,
          to: toGroup || dependent,
        }
        if (mapData.every((m) => m.from !== newMapData.from || m.to !== newMapData.to)) {
          mapData.push(newMapData)
          if (clusters.length > 0) {
            maps.push(`  ${name} -> ${toName(dependent)}[color = "${color}" ${clusters.join(' ')}]`)
          } else {
            maps.push(`  ${name} -> ${toName(dependent)}[color = "${color}"]`)
          }
        }
      } else {
        maps.push(`  ${name} -> ${toName(dependent)}[color = "${color}"]`)
      }
    }
  }
  const nodeExpression = Array.from(nodes).map(([n, color]) => `  ${toName(n)}[label = "${n}", color = "${color}"]`)

  if (nestedGroups) {
    for (const group of nestedGroups) {
      subgraphs.push(nestedGroupToSubgraph(group, 0))
    }
  }

  return `// generated by package-dependency-graph
digraph {
${[...subgraphs, ...maps].join('\n')}

${nodeExpression.join('\n')}
}`
}

function nestedGroupToSubgraph(nestedGroup: NestedGroup, depth: number): string {
  const indent = ' '.repeat(depth * 2)
  const nodes: string[] = []
  const children: NestedGroup[] = []
  for (const child of nestedGroup.children) {
    if (typeof child === 'string') {
      nodes.push(child)
    } else {
      children.push(child)
    }
  }
  return `  ${indent}subgraph cluster_${toName(nestedGroup.name)} {
    ${indent}${nodes.map((n) => toName(n)).join(' ')}${nodes.length > 0 ? ';' : ''}
${children.map((c) => nestedGroupToSubgraph(c, depth + 1)).join('\n')}
    ${indent}label = "${nestedGroup.name}";
    ${indent}color = "${nestedGroup.color}";
  ${indent}}
${indent}`
}

function toName(dependency: string) {
  return dependency.replace(/-/g, '_').replace(/\//g, '_').replace(/@/g, '_').replace(/ /g, '_').replace(/\./g, '_')
}
